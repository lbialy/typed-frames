package org.virtuslab.typedframes

package object internal {
  import scala.language.experimental.macros
  import scala.reflect.macros.blackbox

  /**
    * Those are Blackbox macros. This means the types generated by them are known before the macro is expanded.
    * Safer, more sane. Definitely less magical and more IDE-friendly.
    *
    * @param c: blackbox.Context - this context object is provided by the Scala compiler.
    */
  private[typedframes] class ColumnsBlackboxMacros(val c: blackbox.Context) {
    import c.universe._

    /**
      * Decompose lambda passed to function calling this macro - the only lambda that will work is a lambda
      * that accesses a field on the single argument of passed function (vd.name == idt.name). All we are
      * doing is taking the fieldName and returning it.
      *
      * It's a compile-time reflection based on parsing lambda's AST!
      *
      * @param selector: c.Tree - a scala AST of a lambda function
      * @return c.Tree - a scala AST of literal String instance
      */
    def colNameMacroImpl(selector: c.Tree): c.Tree = {
      selector match {
        case q"(${vd: ValDef}) => ${idt: Ident}.${fieldName: Name}" if vd.name == idt.name =>
          Literal(Constant(fieldName.toString()))
        case _ =>
          c.abort(
            c.enclosingPosition,
            "Lambda expression passed to column method has to return one of the fields of the case class."
          )
      }
    }

    /**
      * Generates a list of names of fields defined in case class A. Method uses compile-time reflection
      * by asking the compiler to provide a c.WeakTypeTag instance for type A.
      *
      * @tparam A - a type designating your case class (a tuple would also work but why would you do that?)
      * @return List[String] - list of names of all fields in case class in declaration order
      */
    def allColNameMacroImpl[A <: Product: c.WeakTypeTag]: c.Tree = {
      val fieldNames: List[String] = allFieldsOfCaseClass[A]

      q"$fieldNames"
    }

    /**
      * An org.apache.spark.sql.ColumnName version of [[allColNameMacroImpl]].
      *
      * @tparam A - a type designating your case class
      * @return List[ColumnName] - list of names of all fields in case class in declaration order wrapped in ColumnName
      */
    def allColNameColumnNameMacroImpl[A <: Product: c.WeakTypeTag]: c.Tree = {
      val fieldNames: List[String] = allFieldsOfCaseClass[A]

      q"$fieldNames.map(fn => new _root_.org.apache.spark.sql.ColumnName(fn))"
    }

    /**
      * An org.apache.spark.sql.ColumnName version of [[colNameMacroImpl]].
      *
      * @param selector: c.Tree - a scala AST of a lambda function
      * @return c.Tree - a scala AST of a call to [[org.apache.spark.sql.ColumnName]] constructor with String value
      *         of field name as argument
      */
    def colNameColumnNameMacroImpl(selector: c.Tree): c.Tree = {
      selector match {
        case q"(${vd: ValDef}) => ${idt: Ident}.${fieldName: Name}" if vd.name == idt.name =>
          val colNameStr = Literal(Constant(fieldName.toString()))
          q"new _root_.org.apache.spark.sql.ColumnName($colNameStr)"
        case _ =>
          c.abort(
            c.enclosingPosition,
            "Lambda expression passed to column method has to return one of the fields of the case class."
          )
      }
    }

    /**
      * A version of [[colNameMacroImpl]] that allows for proper DataFrame column lineage tracking for use in
      * scenarios of joins between tables that contain columns with the same name.
      *
      * @param selector: c.Tree - a scala AST of a lambda function
      * @param df - c.Tree - a scala AST representing an instance of Spark's Dataset[?] - we don't care about
      *           type parameter used to parameterize Dataset type, we only call [[org.apache.spark.sql.Dataset.col]]
      *           method on it.
      * @return c.Tree - a scala AST of a [[org.apache.spark.sql.Column]] returned by .col method
      */
    def colNameDataFrameTwoArgMacroImpl(selector: c.Tree, df: c.Tree): c.Tree = {
      selector match {
        case q"(${vd: ValDef}) => ${idt: Ident}.${fieldName: Name}" if vd.name == idt.name =>
          val colNameStr = Literal(Constant(fieldName.toString()))
          q"$df.col($colNameStr)"
        case _ =>
          c.abort(
            c.enclosingPosition,
            "Lambda expression passed to column method has to return one of the fields of the case class."
          )
      }
    }

    private def allFieldsOfCaseClass[A: WeakTypeTag] =
      implicitly[c.WeakTypeTag[A]].tpe.members.sorted.collect {
        case m: MethodSymbol if m.isCaseAccessor => m.name.toString
      }

  }

}
